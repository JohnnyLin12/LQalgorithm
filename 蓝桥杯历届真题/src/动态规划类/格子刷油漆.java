package 动态规划类;

import java.util.Scanner;


public class 格子刷油漆 {
	public static void main(String[] args) {
		Scanner scan=new Scanner(System.in);
		int n=scan.nextInt();
		/*
		a[i]数组表示从最边缘的四个格子中某个出发，遍历完长度为i，个数为2i个格子的所有种类数；
		2.b[i]数组表示从除了最边缘的四个格子外的某个中间的格子出发，遍历完一边回到所对的格子；
		 */
		long a[]=new long[n+1];
		long b[]=new long[n+1];
		long sum;
		//从同一行的格子出发，回到他所对的格子；
		//或者从他对角的格子出发，回到他所对的格子。
		//b[i]=2*b[i-1];
		b[1]=1;
		for(int i=2;i<=n;i++){
			b[i]=2*b[i-1]%1000000007;
		}
		/*
		先走与这个格子（以左上角的格子为例）在同一列的格子，
		然后从下面这个格子的位置出发，有两种走法，分别到第二列的两个格子，
		所以第一种情况有：2a[i-1]种
		
		先从左上角的格子走到临近列（第二列）的某个格子，然后从第二列的格子出发，
		遍历完右面所有的格子，再回到第二列格子所对的格子，
		最后到第一列未遍历的格子，所以这种情况就是我们定义的b[i]；
		b[i]比较简单，只有两种情况，从同一行的格子出发，回到他所对的格子；
		或者从他对角的格子出发，回到他所对的格子
		所以，b[i]=2*b[i-1];
		
		就是遍历完一二列的所有格子，从第三列的格子出发，进行遍历。
		由于遍历完一二列的所有格子有四种情况，所以第三种情况为：4a[i-2];
		*/
		


		a[1]=1;a[2]=6;
		for(int i=3;i<=n;i++){
			a[i]=(2*a[i-1]+b[i]+4*a[i-2])%1000000007;
		}
		sum=(4*a[n])%1000000007;
		for(int i=2;i<n;i++){
			sum+=((8*b[i-1]*a[n-i])%1000000007+(8*b[n-i]*a[i-1])%1000000007)%1000000007;//必须每个项都取余，防止有大于这个数的情况
			sum%=1000000007;
		}
		System.out.println(sum);
	}


}


