/*

标题：测试次数

x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。
各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，
并且评定出一个耐摔指数来，之后才允许上市流通。
x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。
塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。
如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。
特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。
如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n
为了减少测试次数，从每个厂家抽样3部手机参加测试。
某次测试的塔高为1000层，如果我们总是采用最佳策略，
在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？

请填写这个最多测试次数。

注意：需要填写的是一个整数，不要填写任何多余内容。

 */
/*
 * 注意到测试的次数与手机数和手机耐摔指数有关 
 * 打表 得到递推关系
 * f1(i)=i	f1(i)表示只有一台手机耐摔指数为i时最多测试次数为i
 * 这是因为只有一台手机 所以只能从1层开始测试起（否则可能会被摔坏 就没手机了）
 * 
 * 这里要理解最坏运气与最优策略
 * 所谓最坏运气就是测试次数往最多的方向发展 最优策略时在测试次数往最多方向发展的所有可能种的最小值
 * f2(i)=
 */
package 第九届;
/**
* @author JohnnyLin
* @version Creation Time：2020年5月28日 下午10:15:57
*/
public class t04_测试次数2 {
	static final int  N=1000;
	public static void main(String[] args) {
		int f1[]=new int [N+1];
		int f2[]=new int [N+1];
		int f3[]=new int [N+1];
		
		//一部手机时
		for (int i = 1; i <= N; i++) {
			f1[i]=i;
		}
		//两部手机时
		
		//手机耐摔指数为i时
		for (int i = 1; i <=N; i++) {
			int ans=Integer.MAX_VALUE;
			/*枚举开始测试的层数j	每一层测试结果有两种 
			 *1、摔坏了
			记住摔了手机数就少了一个 该手机的测试次数为：1+f1[j-1]
			2、 或者还是好的 该手机的测试次数为：f2[i-j]
			两者取一个max作为该手机在该层开始测试的最多测试次数
			最优策略为i层中所有最多测试次数的最小值某一个j值
			*/
			for (int j = 1; j <=i; j++) {
				int max = 1+Math.max(f1[j-1], f2[i-j]);
				ans=Math.min(max, ans);
			}
			f2[i]=ans;
			
		}
		
		//三部手机时
		for (int i = 1; i <=N; i++) {
			int ans=Integer.MAX_VALUE;
			for (int j = 1; j <=i; j++) {
				int max = 1+Math.max(f2[j-1], f3[i-j]);
				ans=Math.min(max, ans);
			}
			f3[i]=ans;
			
		}
		System.out.println(f3[N]);
	}

}
